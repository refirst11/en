---
title: SentenceⅢ
subtitle: ''
date: '2026-01/30'
---

This article will be a collection of the nitty-gritty things I've done.

Early on, around September 2023, an acquaintance introduced me to a small library called type-prisma. They asked me to use it, but while I could write in prisma, I didn't see the need to write in TS, so I ended up not using it at the time.

Later, I discovered libraries like type-graphql and type-rust.

These are libraries that use TypeScript to automatically generate graphql types and generate rust code.

While struggling with ChatGPT, I wondered if I could write CSS using a TS-type-only DSL, but unfortunately I was told that CSS in JS cannot be reproduced with type definitions alone.

TS interfaces do not have values.

This was not possible because CSS in JS always has a JS entity.

Two years have passed since then, and I've gone through a process of trial and error, destroying the architecture of the initial lib implementation and rebuilding a new one.

In the end, I arrived at the idea originally conceived by Linaria: a stub implementation.

```ts
function create() {
  throw Error('runtime error');
}
```

In this way, the API was used as a box, holding values ​​but subjecting them to infeasible constraints, with all extraction controlled by plugins.

Yes, this is Zero-Runtime! I was delighted. This was because I began to explore optimizations similar to, and even more than, StyleX.

Naturally, HMR using AST analysis was necessary for server components.
And the runtime compiler also transformed into an AST analysis compiler.

An ambitious idea that had been dormant in me from the beginning: have your cake and eat it too, and eat it without getting fat.

The idea of ​​not wanting to mix runtimes evolved into not wanting to mix bundles either.

The next-level, final achievement was the creation of Plumeria, a Zero-Runtime implementation of stubs.

However, that was just riding on the original idea of ​​Linaria and StyleX's stub functions.

And so, we return to the original story. What ChatGPT said it couldn't do was true, and what it said it couldn't do was realized in a different way.

That is the act of extracting an AST using only type definitions.

My implementation already had that, and the current lib had already achieved that.

I removed main and module from package.json and ran a test.
HMR and build compilation both worked successfully, and it worked as if nothing had happened.

I had to think about what this meant later.

If it were just type definitions without js in the first place, it's neither Zero-Runtime nor a library; it's just a package containing types.

I reached the other side of complete Zero-Runtime and realized something.
To put it dramatically, we're on the other side of the CSS universe.

This meant that we were no longer concerned about bundle size or initial growth, and the concept of value no longer existed.
It could no longer be called CSS in JS; the only way to call it that was possible was to call it a type definition or a framework. As we continued to solve problems rather than the framework we were aiming for, it no longer even called CSS in JS.

All that remained was the concept of types + extraction.

However, the concept of building with type extraction clearly has only advantages, so I think it will be useful in future technological developments.
