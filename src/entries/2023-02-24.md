---
title: Migrating from stable to App Route in Next.js 13 RSC
subtitle: I have fully migrated to the experimental beta feature.
date: '2023-02-24'
---

will write about the new Function API Route Handlers introduced in Next.js version 13.20, which has been completely migrated to the app directory.

- robots.txt
- sitemap.xml
- feed.xml

just got a whole lot easier.
It doesn't need to use any library.
There could be a nicer way to do this, but it just returns the html of the string as xml.

```ts title="app/sitemap.xml/route.ts" {6-22} showLineNumbers
import getAllPosts from 'lib/getAllPosts';

export async function GET() {
  const site_url = process.env.PROD_URL;
  const posts = await getAllPosts();
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       <url>
         <loc>${site_url}</loc>
       </url>
       ${posts
         .map(({ slug }) => {
           return `
         <url>
             <loc>${`${site_url}/${slug}`}</loc>
         </url>
       `;
         })
         .join('')}
     </urlset>
   `;
  return new Response(xml, { headers: { 'content-type': 'application/xml' } });
}
```

RSS too just returns Response from api in the same way.

```ts title="app/feed.xml/route.ts" {4, 25} showLineNumbers
import getAllPosts from 'lib/getAllPosts';

export async function GET() {
  const items = await getAllPosts();
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
    <rss version="2.0">
      <channel>
        <title>su-pull</title>
        <link>${process.env.PROD_URL}</link>
        <description>the 2xxx year fight of my load</description>
        ${items
          .map(
            (item) => `
              <item>
                <title>${item.title}</title>
                <description>${item.subtitle}</description>
                <link>${item.slug}</link>
                <pubDate>${item.date}</pubDate>
              </item>
            `
          )
          .join('')}
      </channel>
    </rss>`;
  return new Response(xml, { headers: { 'content-type': 'application/xml' } });
}
```

The API handlers themselves act as xml pages, which are always up to date with getAllPosts fetches.

Also, the new data fetch is much easier and more visual.
Especially only this,

```tsx title="posts/page.tsx" {2-3, 7}
async function getPosts() {
  const posts = await getAllPosts();
  return posts;
}

async function Page() {
  const posts = await getPosts();
...
}
```

No more eyes going up and down like props bucket brigade, You can receive it directly.
It's easy because you can receive it without needing to type it.

and. \_documents.tsx and \_app.tsx a now layout.tsx.
Inherited from app, you can still write common processing on all pages.

```tsx title="app/layout.tsx"  showLineNumbers {7}
import AppProvider from 'components/AppProvider';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <AppProvider>{children}</AppProvider>
      </body>
    </html>
  );
}
```

From the body down the processing in app.tsx so far with RootLayout.
I sandwiched the processing in app.tsx so far with layout.

And don't forget 'use client', which makes Next.js the server default and succeeds in thinning it out.

Components prefixed with client can be included in dynamically async components.

components. In other words, even with `async (server component)`,
You are free to include any `'use client' component`.

AppProvider component is 'use client' in the RootLayout example above.

## Bug

i inspected framer motion of exit animation layout shift is fast out.
The behavior is too fast compared to the mount, causing styles to be frequently missed.
Looking forward to the template.tsx.

## In summary

This is just my impression, but I don't feel constrained by the RSC.
Enjoy the new async fetch and API Handlers and RootLayout.
